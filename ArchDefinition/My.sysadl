Model SysADLModel ; package INHABS_Types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } value type Transaction { } value type Block { } value type Task { } value type SmartContract extends Task { } value type SimpleTask extends Task { } value type CompositeTask extends Task { } value type Configuration { } value type Message { } value type Command { } datatype VectorTasks { attributes : tasks : Task ; } value type SystemDescription { } datatype TaskMapping { attributes : system : SystemDescription ; taks : VectorTasks ; } enum Status { on , off } datatype SystemStatus { attributes : status : Status ; } datatype TrigersCompositeTask { attributes : compositeTask : CompositeTask ; trigger : Trigger ; } value type Trigger { } value type Query { } } package INHABS_Connectors { import INHABS_Ports ; import INHABS_Compents ; import INHABS_Types ; connector def TaskCN { participants : ~ pi : TaskIPT ; ~ po : TaskOPT ; flows : Task from po to pi } connector def TransactionCN { participants : ~ pi : TransactionIPT ; ~ po : TransactionOPT ; flows : Transaction from po to pi }  connector def ConfigurationCN { participants : ~ pi : ConfigurationIPT ; ~ po : ConfigurationOPT ; flows : Configuration from po to pi } connector def CompositeTaskCN { participants : ~ po : CompositeTaskIPT ; ~ pi : CompositeTaskOPT ; flows : CompositeTask from po to pi } connector def SmartContractCN { participants : ~ pi : SmartContractIPT ; ~ po : SmartContractOPT ; flows : SimpleTask from po to pi } connector def SimpleTaskCN { participants : ~ pi : SimpleTaskIPT ; ~ po : SimpleTaskOPT ; flows : SimpleTask from po to pi } connector def MessageCN { participants : ~ pi : MessageIPT ; ~ po : MessageOPT ; flows : Message from po to pi } connector def VectortasksCN { participants : ~ pi : VectorTasksIPT ; ~ po : VectorTasksOPT ; } connector def BlockCN { participants : ~ pi : BlockIPT ; ~ po : BlockOPT ; flows : Block from po to pi } } package INHABS_Compents { import INHABS_Ports ; import INHABS_Types ; import INHABS_Connectors ;
	component def INHABS_Level3 { ports : p22 : TaskIPT ; p21 : TransactionOPT ; configuration { components : L2 : Level2CP ; S1L3 : SmartCitySystem ; S2L3 : SmartCitySystem ; ADL2 : AdapterCP ; ADS1L3 : AdapterCP ; ADS2L3 : AdapterCP ; BKL3 : BrokerCP ; BCL2 : BlockchainNodeCP ; BCS1L3 : BlockchainNodeCP ; BCS2L3 : BlockchainNodeCP ; LinkingBlockchainCP : LinkingBlockchainCP ; } } boundary
	component def SmartCitySystem { ports : p3 : TaskIPT ; p4 : TransactionOPT ; }
	component def AdapterCP { ports : p7 : TransactionIPT ; p8 : TaskOPT ; p9 : SysStatusOPT ; }
	component def LevelComposerCP { ports : p10 : CompositeTaskOPT ;  p11 : VectorTasksIPT ; }
	component def LevelOrchestratorCP { ports : p15 : CompositeTaskIPT ; p17 : ConfigurationIPT ; p18 : SysStatusIPT ; p16 : TaskMappingIPT ; p14 : CommandOPT ; p18 : TriggersCompositeTaskOPT ; }
	component def BlockchainNodeCP { ports : p12 : TransactionIPT ;  p13 : BlockIPT ; p23 : BlockOPT ; p27 : TransactionOPT ; }
	component def BrokerCP { ports : p1 : MessageIPT ; p2 : BlockOPT ; p23 : TransactionIPT ; p24 : TaskIPT ; }
	component def Level1CP { ports : p6 : TaskIPT ; p5 : TransactionOPT ; configuration { components :  ADS2L1 : AdapterCP ; BCS1L1 : BlockchainNodeCP ; BCS2L1 : BlockchainNodeCP ;  ADS3L1 : AdapterCP ; BCS3L1 : BlockchainNodeCP ; S1L1 : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } S2L1 : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } SmartCitySystem : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } BKL1 : BrokerCP { using ports : pi : MessageIPT ;  } ADS1L1 : AdapterCP { using ports : pi : TransactionIPT ; po : TaskOPT ; po : SysStatusOPT ; } LOL1 : LevelOrchestratorCP { using ports : p15 : CompositeTaskIPT ; p17 : ConfigurationIPT ; p18 : SysStatusIPT ; p16 : TaskMappingIPT ; p14 : CommandOPT ; p18 : TriggersCompositeTaskOPT ; } LCL1 : LevelComposerCP { using ports : p10 : CompositeTaskOPT ; p11 : VectorTasksIPT ; } connectors : c1 : CompositeTaskCN bindings p15 = p10 ; } }
	component def Level2CP { ports : p19 : TaskIPT ; p20 : TransactionOPT ; configuration { components : L1 : Level1CP ; ADL1 : AdapterCP ; S1L2 : SmartCitySystem ; ADS1L2 : AdapterCP ; BKL2 : BrokerCP ; S2L2 : SmartCitySystem ; ADS2L2 : AdapterCP ; BCL1 : BlockchainNodeCP ; BCS1L2 : BlockchainNodeCP ; BCS2L2 : BlockchainNodeCP ; CPL2 : LevelComposerCP ; MNL2 : LevelOrchestratorCP ; } }
	component def LinkingBlockchainCP { } } package INHABS_Ports { import INHABS_Types ; port def TaskIPT { flow in Task } port def TaskOPT { flow out Task } port def TransactionIPT { flow in Transaction } port def TransactionOPT { flow out Transaction } port def BlockIPT { flow in Block }  port def CompositeTaskIPT { flow in CompositeTask } port def CompositeTaskOPT { flow out CompositeTask } port def SmartContractIPT { flow in SmartContract } port def SmartContractOPT { flow out SimpleTask } port def SimpleTaskIPT { flow in SimpleTask } port def SimpleTaskOPT { flow out SimpleTask } port def ConfigurationIPT { flow in Configuration } port def ConfigurationOPT { flow out Configuration } port def MessageIPT { flow in Message }  port def CommandIPT { flow in Command }  port def CommandOPT { flow out Command } port def SysDescriptionIPT { flow in SystemDescription } port def SysDescriptionOPT { flow out SystemDescription } port def SysStatusIPT { flow in SystemStatus } port def SysStatusOPT { flow out SystemStatus } port def TaskMappingIPT { flow in TaskMapping } port def TaskMappingOPT { flow out TaskMapping } port def QueryIPT { flow in Query } port def QueryOPT { flow out Query } port def VectorTasksIPT { flow in VectorTasks } port def VectorTasksOPT { flow out VectorTasks } port def TriggersCompositeTaskIPT { flow in TrigersCompositeTask } port def TriggersCompositeTaskOPT { flow out TrigersCompositeTask } port def BlockOPT { flow out Block } port def MessageOPT { flow out Message } }