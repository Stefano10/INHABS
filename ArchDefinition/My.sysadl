Model SysADLModel ; package INHABS_Types { value type Int { } value type Boolean { } value type String { } value type Void { } value type Real { } value type Transaction { } value type Block { } value type Task { } value type SmartContract extends Task { } value type SimpleTask extends Task { } value type CompositeTask extends Task { } value type Configuration { } value type Message { } value type Command { } datatype VetorTasks { attributes : tasks : Task ; } value type System { } datatype TaskMapping { attributes : system : System ; taks : VetorTasks ; } enum Status { on , off } datatype SystemStatus { attributes : status : Status ; } datatype TrigersCompositeTask { attributes : compositeTask : CompositeTask ; trigger : Trigger ; } value type Trigger { } value type Query { } } package INHABS_Connectors { import INHABS_Ports ; import INHABS_Compents ; import INHABS_Types ; connector def TaskCN { participants : ~ pi : TaskIPT ; ~ po : TaskOPT ; flows : Task from po to pi } connector def TransactionCN { participants : ~ pi : TransactionIPT ; ~ po : TransactionOPT ; flows : Transaction from po to pi } connector def BlockCN { participants : ~ pi : BlockIPT ; ~ po : BlockOPT ; flows : Block from po to pi } connector def ConfigurationCN { participants : ~ pi : ConfigurationIPT ; ~ po : ConfigurationOPT ; flows : Configuration from po to pi } connector def CompositeTaskCN { participants : ~ po : CompositeTaskIPT ; ~ pi : CompositeTaskOPT ; flows : CompositeTask from po to pi } connector def SmartContractCN { participants : ~ pi : SmartContractIPT ; ~ po : SmartContractOPT ; flows : SimpleTask from po to pi } connector def SimpleTaskCN { participants : ~ pi : SimpleTaskIPT ; ~ po : SimpleTaskOPT ; flows : SimpleTask from po to pi } connector def MessageCN { participants : ~ pi : MessageIPT ; ~ po : MessageOPT ; flows : Message from po to pi } } package INHABS_Compents { import INHABS_Ports ; import INHABS_Types ; import INHABS_Connectors ;
	component def INHABS_Level3 { ports : pi : TaskIPT ; po : TransactionOPT ; configuration { components : L2 : Level2CP ; S1L3 : SmartCitySystem ; S2L3 : SmartCitySystem ; ADL2 : AdapterCP ; ADS1L3 : AdapterCP ; ADS2L3 : AdapterCP ; BKL3 : BrokerCP ; BCL2 : BlockchainNodeCP ; BCS1L3 : BlockchainNodeCP ; BCS2L3 : BlockchainNodeCP ; LinkingBlockchainCP : LinkingBlockchainCP ; } } boundary
	component def SmartCitySystem { ports : pi : TaskIPT ; po : TransactionOPT ; }
	component def AdapterCP { ports : pi : TransactionIPT ; po : TaskOPT ; }
	component def LevelComposerCP { ports : po : CompositeTaskOPT ; pi : ConfigurationIPT ; }
	component def LevelManagerCP { ports : pi : CompositeTaskIPT ; pi : ConfigurationIPT ; }
	component def BlockchainNodeCP { ports : pi : TransactionIPT ; po : BlockOPT ; }
	component def BrokerCP { ports : pi : MessageIPT ; po : MessageOPT ; }
	component def Level1CP { ports : pi : TaskIPT ; po : TransactionOPT ; configuration { components : ADS1L1 : AdapterCP ; ADS2L1 : AdapterCP ; BCS1L1 : BlockchainNodeCP ; BCS2L1 : BlockchainNodeCP ; CPL1 : LevelComposerCP ; ADS3L1 : AdapterCP ; BCS3L1 : BlockchainNodeCP ; S1L1 : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } S2L1 : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } SmartCitySystem : SmartCitySystem { using ports : pi : TaskIPT ; po : TransactionOPT ; } BKL1 : BrokerCP { using ports : pi : MessageIPT ; po : MessageOPT ; } MNL1 : LevelManagerCP { using ports : pi : CompositeTaskIPT ; } } }
	component def Level2CP { ports : pi : TaskIPT ; po : TransactionOPT ; configuration { components : L1 : Level1CP ; ADL1 : AdapterCP ; S1L2 : SmartCitySystem ; ADS1L2 : AdapterCP ; BKL2 : BrokerCP ; S2L2 : SmartCitySystem ; ADS2L2 : AdapterCP ; BCL1 : BlockchainNodeCP ; BCS1L2 : BlockchainNodeCP ; BCS2L2 : BlockchainNodeCP ; CPL2 : LevelComposerCP ; MNL2 : LevelManagerCP ; } }
	component def LinkingBlockchainCP { } } package INHABS_Ports { import INHABS_Types ; port def TaskIPT { flow in Task } port def TaskOPT { flow out Task } port def TransactionIPT { flow in Transaction } port def TransactionOPT { flow out Transaction } port def BlockIPT { flow in Block } port def BlockOPT { flow out Block } port def CompositeTaskIPT { flow in CompositeTask } port def CompositeTaskOPT { flow out CompositeTask } port def SmartContractIPT { flow in SmartContract } port def SmartContractOPT { flow out SimpleTask } port def SimpleTaskIPT { flow in SimpleTask } port def SimpleTaskOPT { flow out SimpleTask } port def ConfigurationIPT { flow in Configuration } port def ConfigurationOPT { flow out Configuration } port def MessageIPT { flow in Message } port def MessageOPT { flow out Message } }